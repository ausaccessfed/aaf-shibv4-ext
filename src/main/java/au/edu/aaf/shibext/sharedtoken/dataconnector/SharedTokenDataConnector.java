package au.edu.aaf.shibext.sharedtoken.dataconnector;

import au.edu.aaf.shibext.sharedtoken.dao.JDBCSharedTokenDAO;
import au.edu.aaf.shibext.sharedtoken.dao.SharedTokenDAO;
import au.edu.aaf.shibext.sharedtoken.generator.AuEduPersonSharedTokenGenerator;
import net.shibboleth.idp.attribute.IdPAttribute;
import net.shibboleth.idp.attribute.IdPAttributeValue;
import net.shibboleth.idp.attribute.StringAttributeValue;
import net.shibboleth.idp.attribute.resolver.AbstractDataConnector;
import net.shibboleth.idp.attribute.resolver.ResolutionException;
// import net.shibboleth.idp.attribute.resolver.ResolvedAttributeDefinition;
import net.shibboleth.idp.attribute.resolver.context.AttributeResolutionContext;
import net.shibboleth.idp.attribute.resolver.context.AttributeResolverWorkContext;
import net.shibboleth.utilities.java.support.collection.LazyMap;
import net.shibboleth.utilities.java.support.component.ComponentInitializationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// import javax.sql.DataSource;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import net.shibboleth.idp.attribute.resolver.ResolverDataConnectorDependency;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import net.shibboleth.utilities.java.support.component.ComponentSupport;
import net.shibboleth.idp.attribute.resolver.PluginDependencySupport;
import net.shibboleth.utilities.java.support.annotation.constraint.NonnullAfterInit;
import net.shibboleth.utilities.java.support.primitive.StringSupport;
import net.shibboleth.idp.attribute.EmptyAttributeValue;
import com.google.common.base.Strings;

/**
 * Retrieves an auEduPersonSharedToken â€” this value may exist in the database, otherwise a new value is generated.
 *
 * @author rianniello
 * @see AuEduPersonSharedTokenGenerator
 * @see SharedTokenDAO
 */
public class SharedTokenDataConnector extends AbstractDataConnector {

    private static final Logger LOG = LoggerFactory.getLogger(SharedTokenDataConnector.class);

    @NonnullAfterInit private String sourceInformation;

    @Nullable @NonnullAfterInit public String getSourceAttributeInformation() {
        ComponentSupport.ifNotInitializedThrowUninitializedComponentException(this);
        return sourceInformation;
    }

    /**
     * The name generated by the connector.
     */
    private String generatedAttributeID;

    /**
     * The salt used in auEduPersonSharedToken generation algorithm.
     */
    private String salt;

    /**
     * Used for auEduPersonSharedToken generation.
     */
    private AuEduPersonSharedTokenGenerator auEduPersonSharedTokenGenerator = new AuEduPersonSharedTokenGenerator();

    /**
     * Primary Key name for the tb_st table.
     */
    private String primaryKeyName;

    /**
     * Used to retrieve and store SharedToken values.
     */
    private JDBCSharedTokenDAO sharedTokenDAO;

    @Override protected void doInitialize() throws ComponentInitializationException {

        // Set up the dependencies before initializing the parent.
        // as part of the Object's hash any more (since V4.0)
        super.doInitialize();

    }


    /**
     * Resolves the generatedAttributeID (auEduPersonSharedToken) value.
     *
     * @throws net.shibboleth.idp.attribute.resolver.ResolutionException if sourceAttributeId cannot be resolved
     */
    @Override
    protected Map<String, IdPAttribute> doDataConnectorResolve(AttributeResolutionContext resolutionContext,
                                                               AttributeResolverWorkContext workContext)
            throws ResolutionException {

        LOG.debug("Resolving SharedToken... generatedAttributeID is {}, primaryKeyName {} ",
                generatedAttributeID, primaryKeyName);

        for (final ResolverDataConnectorDependency dataConnectorDependency : getDataConnectorDependencies()) {
            LOG.debug("AAF: " + dataConnectorDependency.getAttributeNames());
        }

        final String sourceId = resolveSourceAttribute(workContext);
        if (Strings.isNullOrEmpty(sourceId)) {
            return null;
        }

        String resolvedSourceIdAttribute = sourceId;

        LOG.debug("AAF: Resolved Source Attribute value: " + resolvedSourceIdAttribute);

        String idpIdentifier = resolutionContext.getAttributeIssuerID();

        LOG.debug("AAF: IssuerID: " + idpIdentifier);

        String uid = resolutionContext.getPrincipal();

        LOG.debug("AAF: Principal: " + uid);

        String sharedToken = sharedTokenDAO.getSharedToken(uid, primaryKeyName);

        if (sharedToken == null) {
            sharedToken = auEduPersonSharedTokenGenerator.generate(resolvedSourceIdAttribute,
                    idpIdentifier, salt);

            sharedTokenDAO.persistSharedToken(uid, sharedToken, primaryKeyName);
        }

        IdPAttribute auEduPersonSharedTokenAttribute = buildAuEduPersonSharedTokenAttribute(sharedToken);
        Map<String, IdPAttribute> attributes = new LazyMap<>();
        attributes.put(auEduPersonSharedTokenAttribute.getId(), auEduPersonSharedTokenAttribute);

        return attributes;
    }

    private IdPAttribute buildAuEduPersonSharedTokenAttribute(String resolvedSourceAttribute) {
        IdPAttribute attribute = new IdPAttribute(this.generatedAttributeID);
        Collection<IdPAttributeValue> attributeValues = new ArrayList<>();
        attributeValues.add(new StringAttributeValue(resolvedSourceAttribute));
        attribute.setValues(attributeValues);
        return attribute;
    }


    /**
     * {@link SharedTokenDataConnector#generatedAttributeID}.
     *
     * @param generatedAttributeID {@link SharedTokenDataConnector#generatedAttributeID}.
     */
    public void setGeneratedAttributeID(String generatedAttributeID) {
        this.generatedAttributeID = generatedAttributeID;

        LOG.debug("AAF: Setting generatedAttributeID: " + generatedAttributeID);
    }

    /**
     * {@link SharedTokenDataConnector#salt}.
     *
     * @param salt {@link SharedTokenDataConnector#salt}.
     */
    public void setSalt(String salt) {
        this.salt = salt;

        LOG.debug("AAF: Setting salt: " + salt);
    }

    /**
     * {@link SharedTokenDataConnector#primaryKeyName}.
     *
     * @param primaryKeyName {@link SharedTokenDataConnector#primaryKeyName}.
     */
    public void setPrimaryKeyName(String primaryKeyName) {
        this.primaryKeyName = primaryKeyName;

        LOG.debug("AAF: Setting primaryKeyName: " + primaryKeyName);
    }

    /**
     * {@link SharedTokenDataConnector#primaryKeyName}.
     *
     * @return primaryKeyName {@link SharedTokenDataConnector#primaryKeyName}.
     */
    public String getPrimaryKeyName() {
        return this.primaryKeyName;
    }

    /**
     * Builds sharedTokenDAO using dataSource.
     *
     */
/* Not required !
    public void setDataSource(DataSource dataSource) {
        this.sharedTokenDAO = new JDBCSharedTokenDAO(dataSource);

        LOG.debug("AAF: Setting dataSource: ");
    }
*/

    /** 
     * {@link SharedTokenDataConnector#sharedTokenDAO}.
     *
     * @param sharedTokenDAO {@link SharedTokenDataConnector#sharedTokenDAO}.
    */
    public void setSharedTokenStore (JDBCSharedTokenDAO sharedTokenDAO) {
        this.sharedTokenDAO = sharedTokenDAO;

        LOG.debug("AAF: Setting sharedTokenDAO: " + sharedTokenDAO);
    }

    @Nullable protected String resolveSourceAttribute(@Nonnull final AttributeResolverWorkContext workContext) {
        ComponentSupport.ifNotInitializedThrowUninitializedComponentException(this);
        ComponentSupport.ifDestroyedThrowDestroyedComponentException(this);

        LOG.debug("AAF: Starting: resolveSourceAttribute ");

        final List<IdPAttributeValue> attributeValues =
                PluginDependencySupport.getMergedAttributeValues(workContext,
                        getAttributeDependencies(),
                        getDataConnectorDependencies(),
                        getId());
        LOG.debug("AAF: resolveSourceAttribute: attributeValues =  " + attributeValues);
        if (attributeValues == null || attributeValues.isEmpty()) {
            LOG.debug("{} Source attribute {} for connector {} provide no values", getLogPrefix(),
                    getSourceAttributeInformation(), getId());
            return null;
        }

        if (attributeValues.size() > 1) {
            LOG.warn("{} Source attribute {} for connector {} has more than one value, only one value is used",
                    getLogPrefix(), getSourceAttributeInformation(), getId());
        }

        final IdPAttributeValue attributeValue = attributeValues.iterator().next();

        final String val;

        if (attributeValue instanceof StringAttributeValue) {
            val = ((StringAttributeValue) attributeValue).getValue();
            if (StringSupport.trimOrNull(val) == null) {
                LOG.warn("{} Source attribute {} for connector {} was all-whitespace", getLogPrefix(),
                        getSourceAttributeInformation(), getId());
                return null;
            }
        } else if (attributeValue instanceof EmptyAttributeValue) {
            final EmptyAttributeValue emptyVal = (EmptyAttributeValue) attributeValue;
            LOG.warn("{} Source attribute {} value for connector {} was an empty value of type {}", getLogPrefix(),
                    getSourceAttributeInformation(), getId(), emptyVal.getDisplayValue());
            return null;
        } else {
            LOG.warn("{} Source attribute {} for connector {} was of an unsupported type: {}", getLogPrefix(),
                    getSourceAttributeInformation(), getId(), attributeValue.getClass().getName());
            return null;
        }

        if (val == null) {
            LOG.warn("{} Attribute value {} for connector {} resolved as empty or null", getLogPrefix(),
                    getSourceAttributeInformation(), getId());
        }
        return val;
    }

}
